/**
 * Import zTEX-Texture
 * ===================
 *
 * This Module can convert a Gothic zTEX-Texture to a bs::Texture.
 *
 *
 * Texture files
 * -------------
 *
 * Gothic stores its textures in a proprietary format called ZTEX, which is basically DDS
 * with a different Header and some minor other modifications.
 *
 * Those ZTEX-files are generated by the game by converting TGA files, which can be seen as
 * caching mechanism. Therefore, in the other game files, the original TGA-name will be used.
 *
 * To still load the correct file, we have to convert the input filename of "SAMPLE.TGA" into
 * "SAMPLE-C.TEX", which is the compiled ZTEX file.
 *
 * In case there is no such compiled ZTEX file, we will try to load the original TGA file instead.
 */

#include "ImportTexture.hpp"
#include <Image/BsPixelData.h>
#include <Image/BsTexture.h>
#include <vdfs/fileIndex.h>
#include <zenload/ztex2dds.h>
#include <Image/BsColor.h>

static std::vector<uint8_t> readCompiledTexture(const std::string& path,
                                                const VDFS::FileIndex& vdfs);
static std::string replaceExtension(const std::string& path, const std::string& newExtension);
static bs::HTexture createRGBA8Texture(bs::UINT32 width, bs::UINT32 height,
                                       const std::vector<uint8_t>& rgbaData);

// - Implementation --------------------------------------------------------------------------------

bs::HTexture BsZenLib::ImportTexture(const std::string& path, const VDFS::FileIndex& vdfs)
{
  using namespace bs;

  std::vector<uint8_t> ztexData = readCompiledTexture(path, vdfs);

  if (ztexData.empty())
  {
    // TODO: Read uncompiled TGA
    return HTexture();
  }

  std::vector<uint8_t> ddsData;
  ZenLoad::convertZTEX2DDS(ztexData, ddsData);

  std::vector<uint8_t> rgbaData;
  ZenLoad::convertDDSToRGBA8(ddsData, rgbaData);

  ZenLoad::DDSURFACEDESC2 surfaceDesc = ZenLoad::getSurfaceDesc(ddsData);

  return createRGBA8Texture(surfaceDesc.dwWidth, surfaceDesc.dwHeight, rgbaData);
}


static bs::HTexture createRGBA8Texture(bs::UINT32 width, bs::UINT32 height,
                                       const std::vector<uint8_t>& rgbaData)
{
  using namespace bs;

  TEXTURE_DESC desc = {};
  desc.type = TEX_TYPE_2D;
  desc.width = width;
  desc.height = width;
  desc.format = PF_RGBA8;

  HTexture texture = Texture::create(desc);
  SPtr<PixelData> pixelData = PixelData::create(desc.width,   //
                                                desc.height,  //
                                                desc.depth,   //
                                                PixelFormat::PF_RGBA8);

  std::vector<Color> colors;
  size_t numPixels = desc.width * desc.height;

  for (size_t i = 0; i < numPixels; i++)
  {
    colors.emplace_back(rgbaData[0 + 4 * i] / 255.0f,   // R
                        rgbaData[1 + 4 * i] / 255.0f,   // G
                        rgbaData[2 + 4 * i] / 255.0f,   // B
                        rgbaData[3 + 4 * i] / 255.0f);  // A
  }

  pixelData->setColors(colors.data(), colors.size());

  texture->writeData(pixelData);

  return texture;
}


static std::vector<uint8_t> readCompiledTexture(const std::string& path, const VDFS::FileIndex& vdfs)
{
  std::string compiledFile = replaceExtension(path, "-C.TEX");

  std::vector<uint8_t> fileData;
  vdfs.getFileData(compiledFile, fileData);

  return fileData;
}


static std::string replaceExtension(const std::string& path, const std::string& newExtension)
{
  // assert(path.length() >= 4);

  if (path.length() < 4)
    return path;

  return path.substr(0, path.length() - 4) + newExtension;
}
